# ---
# jupyter:
#   jupytext:
#     formats: ipynb,py:light
#     text_representation:
#       extension: .py
#       format_name: light
#       format_version: '1.5'
#       jupytext_version: 1.16.4
# ---

"""Git, работа в команде."""

# # Что такое Git
# Универсальный инструмент, который используется в современной разработке
# К базовым возможностям Git относятся:
# 1) Возврат к любой прошлой версии кода
# 2) Просмотр истории изменений
# 3) Восстановление любых данных
# 4) Совместная работа без риска потерять данные или перезаписать чужую работу
#
# ## Установка Git
# Git уже был на моем ноутбуке, для того, чтобы узнать установлен у вас git надо ввести 'git --version'. Вот пример вывода на MacOS git version 2.39.3 (Apple Git-145).
#
# ## Основные команды
# Git может отслеживать файлы проекта только если они помещены под контроль, для того, чтобы инициализировать проект нужно ввести команду git init.Проект может быть либо существующим, либо новым. Пример создания:
# #Создаем новый проект
# # mkdir hexlet-git
#
# #Переходим в созданную директорию
# # cd hexlet-git
#
# #Выполняем инициализацию
# git init
# Initialized empty Git repository in /private/tmp/hexlet-git/.git/
#
# Git init создает репозиторий - директорию .git, еще одна полезная команда git status, с ее помощью мы можем  увидеть статус репозитория:
#
# git status
# On branch main
# No commits yet
# nothing to commit (create/copy files and use "git add" to track)  
#
# ### Создание файлов:
# # echo 'Hello, Hexlet!' > README.md
# # echo 'Haskell Curry' > PEOPLE.md
#
# Но Git самостоятельно не отслеживает изменения или такие новые файлы, так как они не добавлены в репозиторий. Сначала мы должны добавить файл в индекс - git add README.md, после этого мы можем сказать что этот файл готов к изменению. Теперь мы должны закоммитить - это означает окончательное добавление в репозиторий и тогда Git запоминает эти изменения навсегда - git commit -m 'add README.md'. Флаг -m означает message, то есть описание коммита. Коммит можно выполнять и без него, но тогда откроется редактор, в котором нужно будет ввести описание коммита.
#
#

# # Интеграция с GitHub
# ## Как добавить репозиторий
# Репозиторием является именно директория .git. Она хранит всю информацию о том, какие были изменения, а также сами изменения.
# А вот все, что находится снаружи, это так называемая рабочая директория (working directory). Эти файлы извлекаются из .git в момент клонирования.
# Сохраненный репозиторий в любой момент можно извлечь и продолжить работу в нем с последнего добавленного коммита. Это пригодится, если мы случайно удалим или изменим локальный репозиторий так, что с ним станет невозможно работать.
#
# Добавим наш репозиторий на GitHub:
#
# Зарегистрируйтесь на GitHub и создайте ssh-ключи по инструкции. SSH-ключи — это наиболее безопасный способ работы с GitHub, поэтому важно разобраться с ними
# Создайте репозиторий на GitHub. Назовите его hexlet-git. Важно, чтобы репозиторий создавался пустым, поэтому не отмечайте галочки, добавляющие файлы
# На странице репозитория вы увидите готовые команды для подключения созданного репозитория на GitHub к уже существующему репозиторию у вас на компьютере:
# ![image.png](attachment:image.png)
#
# Выполним эти шаги:
# git remote add origin git@github.com:<ИМЯ НА ГИТХАБЕ>/hexlet-git.git
# git branch -M main
# git push -u origin main
#
# ### Что такое SSH-ключ 
# Это пара из приватного и публичноого ключа, они нужны для доступа к репозиториям без ввода пароля при каждой операции

# # Анализ сделанных изменений 
# ## Как анализировать данные 
# Команда git status помогает отслеживать, что происходит/происходило в проекте. 
# Также для того, чтобы мы могли увидеть какие именно изменения произошли в файлах есть команда git diff, но эта команда показывает строки которые изменелись. Слева от строк ставится:
# 1) Знак -, если строка была удалена
# 2) Знак +, если строка была добавлена
# По умолчанию команда git diff показывает изменения только для тех модифицированных файлов, которые еще не были добавлены в индекс. Но можно ввести команды git diff с флагом --staged
#
# ## Анализ истории изменений 
# Самая простая аналитика выполняется командой git log. Показывает историю коммитов отсортированных по дате.У команды git log есть флаг -p, который сразу выводит диф для каждого коммита.У каждого коммита есть уникальный набор символов — идентификатор (еще говорят «хеш»). С помощью хеша можно посмотреть все изменения, сделанные в рамках одного коммита. git show 5120bea(можно вставить первые семь символов). git blame <путь до файла>. Эта команда выводит файл и рядом с каждой строчкой показывает того, кто ее менял и в каком коммите.Команда git grep ищет совпадение с указанной строкой во всех файлах проекта.
#
# ## Отмена изменений в рабоче директории 
# Неотслеживаемые файлы в Git — это файлы, которые присутствуют в вашей рабочей директории, но не добавлены в индекс (и не находятся под контролем версий). Также для отмены изменений в таких файлах используется команда git restore.

# # Отмена коммитов
# Git — система, в которой не нужно бояться совершать ошибки. Можно сказать, что ошибки — это единственный способ научиться им пользоваться. В Git практически всегда есть способ восстановить или изменить любые коммиты. На крайний случай спасет повторный git clone.
# Что делать, если коммит уже сделан, но он нас по каким-то причинам не устраивает? Ситуаций может быть много, и все они возникают регулярно даже у профессиональных разработчиков:
# 1) Забыли добавить в коммит нужные файлы
# 2) Изменения нужно «откатить», чтобы доработать
# 3) Изменения больше не актуальны, и их нужно удалить
# 4) Изменения были сделаны по ошибке, и их нужно отменить
# Отмена изменений просходит при помощи команды git revert. Команда revert может отменять не только последний коммит, но и любой другой коммит из истории проекта. Но есть ситуации когда историю менять нельзя, если коммит был отправлен во внешний репозиторий, то менять историю ни в коем случае нельзя. Это сломает работу у тех, кто работает с вами над проектом. Для удаления коммита используется команда git reset. Также у этой команды есть флаги - флаг --hard означает полное удалени, без этого флага команда просто отменит коммит, но с ним можно будет работать. Флаг HEAD~ означает «один коммит от последнего коммита» (если хотим поменяьт то ставим HEAD~2). 
# Также у команды git reset есть три состояния(флага):
# 1) --hard - полное удаление.
# 2) --mixed - изменения остаются в рабочей директории, но исключаются из индекса (unstage).
# 3) --soft - позволяет сохранить изменения в индексе.
#
# ## Изменение последнего коммита
# Если мы забыли добавить файлы,то у комнады git add есть флаг --amend 

# # Индекс
# Индекс в Git — это специальная промежуточная область, в которой хранятся изменения файлов на пути от рабочей директории до репозитория. При выполнении коммита в него попадают только те изменения, которые были добавлены в индекс. В этом уроке вы узнаете, зачем нужен индекс и как он работает. Индекс нужен в основном, если - ошибки, код с плохим оформлением, фрагменты, которые нужно будет исправить под новые требования.
# Способо работы с индексом -
# git add somefile
# git commit -m 'add somefile', также с помощью команды git add "." (без кавычек) мы можем добавить все файлы в индекс, но нужно быть аккуратным.
#
#
# ## Перемещение по истории
# Git позволяет не только просматривать историю. Еще мы можем перемещаться по истории, загружая в рабочую директорию состояние кода на момент выполнения любого коммита. В этом уроке мы изучим, как перемещаться по истории с помощью команды git checkout. Для того,  чтобы переключиться на определенный коммит нужно - git checkout <хеш коммита>, для того чтобы узнать где мы сейчас находимся, в какой рабочей области можно использовать команду git branch, также примеры вводa:hexlet-git git:(main) - если на последнем коммите, hexlet-git git:(e6f625c) - если на коммите их прошлого
#

# # Понимание Git
# Для более легкого понимания мы можем использовать команду - git log --graph, она выведет коммиты проекта в специальном(более читаемом) виде.Каждый новый коммит базируется на коде предыдущего коммита. С точки зрения информатики коммиты выстраиваются в так называемый односвязный список.Сам список коммитов тоже имеет название. Вы его уже видели — это main. В терминологии Git такой список называется веткой (branch). Но называть ветки в Git односвязанным массивом не совсем правильно, скорее это направленный ациклический граф — множество односвязных списков, переплетенных вместе. В Git мы можем помимо основной ветки, где лежит наш проект, создать другие ветки и работать вместе с другими людьми паралелльно:![image.png](attachment:image.png)
#
# ## Игнорирование файлов
# В процессе работы появляются много ненужных или лишних файлов для нашего проекта:
# 1) Инструментарий(cлужебные файлы, добавляемые операционной системой)
# 2) Временные файлы(логи, кеши)
# 3) Артефакты(результаты сборки проект, зависимости)
# Все это в обычной ситуации не должно попадать в репозиторий. Создаются либо автомаически, либо по запросу

# # Stash
# Stash - это место, куда поподают файлы. Нужен он, когда мы работаем над одним проектом и вдруг надо срочно переключиться на другую задачу/проект, но вносить изменения либо рано, либо файлы еще просто не готовы. Грубо говоря, stash служит неким буфером для сохранения нашего кода для одной задачи, когда мы переключаемся на другю. Вот команды для его использования:
# git stash - вносит наши изменения в stash
# git stash pop - возвращает наши изменения из stash
# ![image.png](attachment:image.png)
